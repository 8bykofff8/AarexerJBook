# Сортировка пузырьком

## Введение

Алгоритм сортировки пузырьком является одним из самых простых алгоритмов.

В данном случае мы используем два вложенных цикла.

## Алгоритм

Идея заключается в том, что за каждую итерацию по массиву мы находим и как бы "поднимаем" наибольший элемент вверх, в верхнюю часть массива.

Мы можем сделать это в цикле `for` или `while` и за один такой цикл мы "поднимаем" один элемент.

Найдя и подняв элемент мы снова начинаем поиск, но уже до `n - 1` элемента массива, ведь в конце у нас уже есть предыдущий "поднятый" элемент.

> Здесь `n` - это длина массива.

После этого мы еще раз делаем то же самое, но уже до `n - 2` и так далее.

Мы делаем `n` итераций, за каждую из которых мы "поднимаем" элементы вверх.

Отсюда и название алгоритама: наибольшие элементы массива всплывают как пузырьки в воде.

Для сортировки пузырьком, как мы уже описали, требуется два вложенных цикла. Внутренний цикл занимается поиском и "поднятием" наибольшего элемента, внешний отвечает за количество таких поисков.

### Производительность

Из-за двух вложенных циклов сортировка пузырьком довольно медленная, ее сложность -  `О(n^2)`.

Можно несколько улучшить результаты, но все равно в худшем случае мы получаем все те же `О(n^2)`.

Сортировка пузырьком будет работать чуть быстрее, если мы применим маленький хак и только в том случае, если массив почти отсортирован.

В таком случае смысла ждать все `n` итераций нет.

Можно завести счетчик `swap`-ов(или обычный `boolean` флаг), т.е счетчик перестановок - который будет сигнализировать о том, были ли во время итерации "всплытия".

Ведь если за одно прохождение по массиву не было ни одной перестановки(читай - "всплытия" элемента), то массив уже отсортирован.

Реализуем оба варианта.

### Реализация

Для простоты мы в обоих случаях будем работать с массивами `int`-ов.

Стандартная реализация сортировки пузырьком выглядит примерно таким образом:

```java
    /**
     * Simple bubble sort example.
     * @param arr array with elements.
     */
    public static void bubbleSort(int[] arr) {
        final int len = arr.length;

        for (int i = 0; i < len - 1; i++) {
            for (int j = 0; j < len - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;
                }
            }
        }
    }
```

Для чуть лучшей производительности можно ввести флаг, сигнализирующий о том, что
массив уже отсортирован, это поможет нам сократить кол-во итераций.

```java
    /**
     * Simple bubble sort, but with flag for performance optimization.
     * @param arr array with elements.
     */
    public static void bubbleSortWithFlag(int[] arr) {
        final int len = arr.length;
        boolean flag;

        for (int i = 0; i < len - 1; i++) {
            flag = false;
            for (int j = 0; j < len - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;
                    flag = true;
                }
            }
            if (!flag) break;
        }
    }
```